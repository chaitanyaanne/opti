import math
import pulp

def assign_with_greedy_and_lp(prob, x, df, num_csms, max_accounts_per_csm=83, min_size_for_greedy=40):
    """
    Two-phase assignment:
    - Phase 1: Greedy preassignment for large families (fix variables).
    - Phase 2: LP solver for remaining accounts and constraints.
    """
    print("Starting greedy preassignment for large families...")

    assigned = set()
    parent_ids = df['parent_account_id'].dropna().unique()
    family_id_counter = 0

    for parent_id in parent_ids:
        family_indices = df.index[df['parent_account_id'] == parent_id].tolist()
        family_size = len(family_indices)

        if family_size < min_size_for_greedy:
            continue  # Leave small families to LP

        csms_needed = math.ceil(family_size / max_accounts_per_csm)

        # Assign in round-robin to avoid CSM overload
        for i in range(csms_needed):
            csm = (family_id_counter + i) % num_csms
            accounts_for_csm = family_indices[i::csms_needed]
            for acc_idx in accounts_for_csm:
                prob += x[acc_idx, csm] == 1, f"greedy_fix_{acc_idx}_{csm}"
                assigned.add((acc_idx, csm))

        family_id_counter += 1

    print(f"Greedy preassignment completed for {family_id_counter} large families.")
    print("Proceeding with LP optimization for the rest...")

    return prob



from collections import defaultdict

def greedy_assignment(df, num_csms, max_accounts_per_csm=83):
    assignments = defaultdict(list)
    csm_load = [0] * num_csms
    csm_index = 0

    for parent_id in df['parent_account_id'].dropna().unique():
        family_indices = df.index[df['parent_account_id'] == parent_id].tolist()
        family_size = len(family_indices)

        csms_needed = math.ceil(family_size / max_accounts_per_csm)
        selected_csms = []

        for _ in range(csms_needed):
            while csm_load[csm_index] + (family_size // csms_needed) > max_accounts_per_csm:
                csm_index = (csm_index + 1) % num_csms
            selected_csms.append(csm_index)
            csm_index = (csm_index + 1) % num_csms

        for idx, acc in enumerate(family_indices):
            assigned_csm = selected_csms[idx % csms_needed]
            assignments[assigned_csm].append(acc)
            csm_load[assigned_csm] += 1

    return assignments






import pandas as pd
from collections import defaultdict

def normalize_pods_after_lp(assignments, df, num_csms, max_accounts_per_csm=83):
    """
    Normalize CSM assignments post-optimization to ensure families (by parent_account_id)
    are consolidated into as few CSMs as possible, removing conflicting accounts if needed.

    Parameters:
    - assignments: list of (account_idx, csm_idx) from LP output
    - df: dataframe with 'parent_account_id' and index matching account_idx
    - num_csms: total number of CSMs
    - max_accounts_per_csm: maximum accounts a CSM can handle

    Returns:
    - normalized_assignments: list of (account_idx, csm_idx)
    """

    # Step 1: Build current state
    csm_to_accounts = defaultdict(list)
    account_to_csm = {}
    for i, j in assignments:
        csm_to_accounts[j].append(i)
        account_to_csm[i] = j

    # Step 2: Group accounts by parent account
    family_groups = df.groupby('parent_account_id').groups

    for parent_id, family_indices in family_groups.items():
        family_indices = list(family_indices)
        if len(family_indices) <= 1:
            continue

        # Count how many from this family were assigned to each CSM
        csm_family_count = defaultdict(int)
        for i in family_indices:
            if i in account_to_csm:
                j = account_to_csm[i]
                csm_family_count[j] += 1

        # Sort CSMs by how many from this family they already have
        preferred_csms = sorted(csm_family_count.items(), key=lambda x: -x[1])
        fallback_csms = [j for j in range(num_csms) if j not in csm_family_count]

        # Combine preferred and fallback
        candidate_csms = [j for j, _ in preferred_csms] + fallback_csms

        reassigned = set()

        for i in family_indices:
            if i in reassigned:
                continue

            for j in candidate_csms:
                # Remove conflicting accounts if needed to make space
                current_family = set(df.loc[csm_to_accounts[j], 'parent_account_id'])

                # If this CSM has accounts from *other* families, remove them
                for acc in csm_to_accounts[j][:]:  # Copy to avoid mutation while iterating
                    if df.loc[acc, 'parent_account_id'] != parent_id:
                        csm_to_accounts[j].remove(acc)
                        reassigned.discard(acc)
                        if acc in account_to_csm:
                            del account_to_csm[acc]

                if len(csm_to_accounts[j]) < max_accounts_per_csm:
                    # Assign this account to CSM j
                    csm_to_accounts[j].append(i)
                    account_to_csm[i] = j
                    reassigned.add(i)
                    break  # Move to next account

    # Final output
    normalized_assignments = [(i, j) for i, j in account_to_csm.items()]
    return normalized_assignments


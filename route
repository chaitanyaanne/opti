import math
import pulp

def assign_with_greedy_and_lp(prob, x, df, num_csms, max_accounts_per_csm=83, min_size_for_greedy=40):
    """
    Two-phase assignment:
    - Phase 1: Greedy preassignment for large families (fix variables).
    - Phase 2: LP solver for remaining accounts and constraints.
    """
    print("Starting greedy preassignment for large families...")

    assigned = set()
    parent_ids = df['parent_account_id'].dropna().unique()
    family_id_counter = 0

    for parent_id in parent_ids:
        family_indices = df.index[df['parent_account_id'] == parent_id].tolist()
        family_size = len(family_indices)

        if family_size < min_size_for_greedy:
            continue  # Leave small families to LP

        csms_needed = math.ceil(family_size / max_accounts_per_csm)

        # Assign in round-robin to avoid CSM overload
        for i in range(csms_needed):
            csm = (family_id_counter + i) % num_csms
            accounts_for_csm = family_indices[i::csms_needed]
            for acc_idx in accounts_for_csm:
                prob += x[acc_idx, csm] == 1, f"greedy_fix_{acc_idx}_{csm}"
                assigned.add((acc_idx, csm))

        family_id_counter += 1

    print(f"Greedy preassignment completed for {family_id_counter} large families.")
    print("Proceeding with LP optimization for the rest...")

    return prob



from collections import defaultdict

def greedy_assignment(df, num_csms, max_accounts_per_csm=83):
    assignments = defaultdict(list)
    csm_load = [0] * num_csms
    csm_index = 0

    for parent_id in df['parent_account_id'].dropna().unique():
        family_indices = df.index[df['parent_account_id'] == parent_id].tolist()
        family_size = len(family_indices)

        csms_needed = math.ceil(family_size / max_accounts_per_csm)
        selected_csms = []

        for _ in range(csms_needed):
            while csm_load[csm_index] + (family_size // csms_needed) > max_accounts_per_csm:
                csm_index = (csm_index + 1) % num_csms
            selected_csms.append(csm_index)
            csm_index = (csm_index + 1) % num_csms

        for idx, acc in enumerate(family_indices):
            assigned_csm = selected_csms[idx % csms_needed]
            assignments[assigned_csm].append(acc)
            csm_load[assigned_csm] += 1

    return assignments
